/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <stdlib.h>
#include <string.h>
#include "SKP_Silk_SDK_API.h"
#include "SKP_Silk_SigProc_FIX.h"

/* Define codec specific settings */
#define MAX_BYTES_PER_FRAME     1024
#define MAX_INPUT_FRAMES        5
#define MAX_FRAME_LENGTH        480
#define FRAME_LENGTH_MS         20
#define MAX_API_FS_KHZ          48
#define MAX_LBRR_DELAY          2

/* Header for class com_l1yp_SilkCodec */

#ifndef _Included_com_l1yp_SilkCodec
#define _Included_com_l1yp_SilkCodec
#ifdef __cplusplus
extern "C" {
#endif


void writeToOutputStream(JNIEnv * env, jobject outputStream, jmethodID writeMethodID, SKP_int16* out, int len) {

    for (size_t i = 0; i < len; i++)
    {
        (*env)->CallVoidMethod(env, outputStream, writeMethodID, out[i] & 0xFF);
        (*env)->CallVoidMethod(env, outputStream, writeMethodID, (out[i] >> 8) & 0xFF);
    }
     
}


/*
 * Class:     com_l1yp_SilkCodec
 * Method:    nativeDecodeSilk
 * Signature: ([BLjava/io/OutputStream;I)I
 */
JNIEXPORT jint JNICALL Java_com_l1yp_SilkCodec_nativeDecodeSilk
  (JNIEnv * env, jobject thisObj, jbyteArray src, jobject outputStream, jint rate) {
    
    jclass outputStreamClass = (*env)->GetObjectClass(env, outputStream);
    jmethodID writeMethodID = (*env)->GetMethodID(env, outputStreamClass, "write", "(I)V");
    if (writeMethodID == NULL) {
        return -1; // 方法未找到，处理错误
    }

    jsize length = (*env)->GetArrayLength(env, src);
    jbyte* bytes = (*env)->GetByteArrayElements(env, src, NULL);
    if (bytes == NULL) {
        // Handle error
        return -1;
    }

    size_t    counter;
    SKP_int32 /*args,*/ totPackets, i, k;
    SKP_int16 ret, len, tot_len;
    SKP_int16 nBytes;
    SKP_uint8 payload[    MAX_BYTES_PER_FRAME * MAX_INPUT_FRAMES * ( MAX_LBRR_DELAY + 1 ) ];
    SKP_uint8 *payloadEnd = NULL, *payloadToDec = NULL;
    SKP_uint8 FECpayload[ MAX_BYTES_PER_FRAME * MAX_INPUT_FRAMES ], *payloadPtr;
    SKP_int16 nBytesFEC;
    SKP_int16 nBytesPerPacket[ MAX_LBRR_DELAY + 1 ], totBytes;
    SKP_int16 out[ ( ( FRAME_LENGTH_MS * MAX_API_FS_KHZ ) << 1 ) * MAX_INPUT_FRAMES ], *outPtr;
    SKP_int32 packetSize_ms=0, API_Fs_Hz = 0;
    SKP_int32 decSizeBytes;
    void      *psDec;
    SKP_float loss_prob;
    SKP_int32 frames, lost;
    SKP_SILK_SDK_DecControlStruct DecControl;

    /* default settings */
    loss_prob = 0.0f;


    API_Fs_Hz = rate;

    int srcOffset = 0;

    {
        /* Check Silk header */
        char header_buf[ 20 ];
        char* magic = bytes[0] == 2 ? "#!SILK_V3" : "!SILK_V3";
        srcOffset++;

        int magicLen = strlen(magic);
        memcpy(header_buf, bytes + srcOffset, magicLen);
        header_buf[magicLen] = '\0';
        if (strcmp(header_buf, magic) != 0) {
            return -2;
        }
        srcOffset += magicLen;
    }
    

    /* Set the samplingrate that is requested for the output */
    if( API_Fs_Hz == 0 ) {
        DecControl.API_sampleRate = 24000;
    } else {
        DecControl.API_sampleRate = API_Fs_Hz;
    }

    /* Initialize to one frame per packet, for proper concealment before first packet arrives */
    DecControl.framesPerPacket = 1;

    /* Create decoder */
    ret = SKP_Silk_SDK_Get_Decoder_Size( &decSizeBytes );

    psDec = malloc( decSizeBytes );

    /* Reset decoder */
    ret = SKP_Silk_SDK_InitDecoder( psDec );
    /*if( ret ) {
        //printf( "\nSKP_Silk_InitDecoder returned %d", ret );
    }*/

    totPackets = 0;
    payloadEnd = payload;

    /* Simulate the jitter buffer holding MAX_FEC_DELAY packets */
    for( i = 0; i < MAX_LBRR_DELAY; i++ ) {
        /* Read payload size */
        nBytes = *((short *) (bytes + srcOffset));
        // printf("1 nBytes: %d\n", nBytes);
        srcOffset += 2;
#ifdef _SYSTEM_IS_BIG_ENDIAN
        swap_endian( &nBytes, 1 );
#endif
        /* Read payload */
        memcpy(payloadEnd, bytes + srcOffset, nBytes);
        srcOffset += nBytes;
        nBytesPerPacket[ i ] = nBytes;
        payloadEnd          += nBytes;
        totPackets++;
    }

    while( srcOffset + 2 < length ) {
        /* Read payload size */
        nBytes = *((short *) (bytes + srcOffset));
        // printf("2 nBytes: %d\n", nBytes);
        srcOffset += 2;
#ifdef _SYSTEM_IS_BIG_ENDIAN
        swap_endian( &nBytes, 1 );
#endif
        if( nBytes <= 0 || srcOffset + nBytes > length) {
            break;
        }

        /* Read payload */
        memcpy(payloadEnd, bytes + srcOffset, nBytes);
        srcOffset += nBytes;

        nBytesPerPacket[ MAX_LBRR_DELAY ] = nBytes;
        payloadEnd                       += nBytes;

        if( nBytesPerPacket[ 0 ] == 0 ) {
            /* Indicate lost packet */
            lost = 1;

            /* Packet loss. Search after FEC in next packets. Should be done in the jitter buffer */
            payloadPtr = payload;
            for( i = 0; i < MAX_LBRR_DELAY; i++ ) {
                if( nBytesPerPacket[ i + 1 ] > 0 ) {
                    SKP_Silk_SDK_search_for_LBRR( payloadPtr, nBytesPerPacket[ i + 1 ], ( i + 1 ), FECpayload, &nBytesFEC );
                    if( nBytesFEC > 0 ) {
                        payloadToDec = FECpayload;
                        nBytes = nBytesFEC;
                        lost = 0;
                        break;
                    }
                }
                payloadPtr += nBytesPerPacket[ i + 1 ];
            }
        } else {
            lost = 0;
            nBytes = nBytesPerPacket[ 0 ];
            payloadToDec = payload;
        }

        /* Silk decoder */
        outPtr = out;
        tot_len = 0;

        if( lost == 0 ) {
            /* No Loss: Decode all frames in the packet */
            frames = 0;
            do {
                /* Decode 20 ms */
                ret = SKP_Silk_SDK_Decode( psDec, &DecControl, 0, payloadToDec, nBytes, outPtr, &len );
                /*if( ret ) {
                    printf( "\nSKP_Silk_SDK_Decode returned %d", ret );
                }*/

                frames++;
                outPtr  += len;
                tot_len += len;
                if( frames > MAX_INPUT_FRAMES ) {
                    /* Hack for corrupt stream that could generate too many frames */
                    outPtr  = out;
                    tot_len = 0;
                    frames  = 0;
                }
                /* Until last 20 ms frame of packet has been decoded */
            } while( DecControl.moreInternalDecoderFrames );
        } else {
            /* Loss: Decode enough frames to cover one packet duration */
            for( i = 0; i < DecControl.framesPerPacket; i++ ) {
                /* Generate 20 ms */
                ret = SKP_Silk_SDK_Decode( psDec, &DecControl, 1, payloadToDec, nBytes, outPtr, &len );
                /*if( ret ) {
                    printf( "\nSKP_Silk_Decode returned %d", ret );
                }*/
                outPtr  += len;
                tot_len += len;
            }
        }

        packetSize_ms = tot_len / ( DecControl.API_sampleRate / 1000 );
        totPackets++;

        /* Write output to file */
#ifdef _SYSTEM_IS_BIG_ENDIAN
        swap_endian( out, tot_len );
#endif
        // fwrite( out, sizeof( SKP_int16 ), tot_len, speechOutFile );
        writeToOutputStream(env, outputStream, writeMethodID, out, tot_len);

        /* Update buffer */
        totBytes = 0;
        for( i = 0; i < MAX_LBRR_DELAY; i++ ) {
            totBytes += nBytesPerPacket[ i + 1 ];
        }
        /* Check if the received totBytes is valid */
        if (totBytes < 0 || totBytes > sizeof(payload))
        {
            // fprintf( stderr, "1 Packets decoded:             %d\n", totPackets );
            return -5;
        }
        SKP_memmove( payload, &payload[ nBytesPerPacket[ 0 ] ], totBytes * sizeof( SKP_uint8 ) );
        payloadEnd -= nBytesPerPacket[ 0 ];
        SKP_memmove( nBytesPerPacket, &nBytesPerPacket[ 1 ], MAX_LBRR_DELAY * sizeof( SKP_int16 ) );

        // fprintf( stderr, "2 Packets decoded:             %d\n", totPackets );
    }

    /* Empty the recieve buffer */
    for( k = 0; k < MAX_LBRR_DELAY; k++ ) {
        if( nBytesPerPacket[ 0 ] == 0 ) {
            /* Indicate lost packet */
            lost = 1;

            /* Packet loss. Search after FEC in next packets. Should be done in the jitter buffer */
            payloadPtr = payload;
            for( i = 0; i < MAX_LBRR_DELAY; i++ ) {
                if( nBytesPerPacket[ i + 1 ] > 0 ) {
                    SKP_Silk_SDK_search_for_LBRR( payloadPtr, nBytesPerPacket[ i + 1 ], ( i + 1 ), FECpayload, &nBytesFEC );
                    if( nBytesFEC > 0 ) {
                        payloadToDec = FECpayload;
                        nBytes = nBytesFEC;
                        lost = 0;
                        break;
                    }
                }
                payloadPtr += nBytesPerPacket[ i + 1 ];
            }
        } else {
            lost = 0;
            nBytes = nBytesPerPacket[ 0 ];
            payloadToDec = payload;
        }

        /* Silk decoder */
        outPtr  = out;
        tot_len = 0;

        if( lost == 0 ) {
            /* No loss: Decode all frames in the packet */
            frames = 0;
            do {
                /* Decode 20 ms */
                ret = SKP_Silk_SDK_Decode( psDec, &DecControl, 0, payloadToDec, nBytes, outPtr, &len );
                /*if( ret ) {
                    printf( "\nSKP_Silk_SDK_Decode returned %d", ret );
                }*/

                frames++;
                outPtr  += len;
                tot_len += len;
                if( frames > MAX_INPUT_FRAMES ) {
                    /* Hack for corrupt stream that could generate too many frames */
                    outPtr  = out;
                    tot_len = 0;
                    frames  = 0;
                }
                /* Until last 20 ms frame of packet has been decoded */
            } while( DecControl.moreInternalDecoderFrames );
        } else {
            /* Loss: Decode enough frames to cover one packet duration */

            /* Generate 20 ms */
            for( i = 0; i < DecControl.framesPerPacket; i++ ) {
                ret = SKP_Silk_SDK_Decode( psDec, &DecControl, 1, payloadToDec, nBytes, outPtr, &len );
                /*if( ret ) {
                    printf( "\nSKP_Silk_Decode returned %d", ret );
                }*/
                outPtr  += len;
                tot_len += len;
            }
        }

        packetSize_ms = tot_len / ( DecControl.API_sampleRate / 1000 );
        totPackets++;

        /* Write output to file */
#ifdef _SYSTEM_IS_BIG_ENDIAN
        swap_endian( out, tot_len );
#endif
        // fwrite( out, sizeof( SKP_int16 ), tot_len, speechOutFile );
        writeToOutputStream(env, outputStream, writeMethodID, out, tot_len);

        /* Update Buffer */
        totBytes = 0;
        for( i = 0; i < MAX_LBRR_DELAY; i++ ) {
            totBytes += nBytesPerPacket[ i + 1 ];
        }

        /* Check if the received totBytes is valid */
        if (totBytes < 0 || totBytes > sizeof(payload))
        {

            // fprintf( stderr, "3 Packets decoded:              %d\n", totPackets );
            return -6;
        }

        SKP_memmove( payload, &payload[ nBytesPerPacket[ 0 ] ], totBytes * sizeof( SKP_uint8 ) );
        payloadEnd -= nBytesPerPacket[ 0 ];
        SKP_memmove( nBytesPerPacket, &nBytesPerPacket[ 1 ], MAX_LBRR_DELAY * sizeof( SKP_int16 ) );

        // fprintf( stderr, "4 Packets decoded:              %d\n", totPackets );
    }


    /* Free decoder */
    free( psDec );

    return 0;
  }

#ifdef __cplusplus
}
#endif
#endif
